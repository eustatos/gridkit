# CORE-014-1: Table Event Bridge

## Task Card

```
task_id: CORE-014-1
priority: P0
complexity: Medium
estimated_tokens: ~4,000
ai_ready: yes
dependencies: [CORE-001, CORE-002, CORE-005A, CORE-010, CORE-011]
requires_validation: true (event flow)
```

## ðŸŽ¯ **Objective**

Create the main event bridge between table instance and event system, translating table operations into events and vice versa. Implement core event emission for state changes.

## ðŸ“‹ **Implementation Scope**

### **1. Main Table Event Bridge**

```typescript
// packages/core/src/events/integration/table-event-bridge.ts
export function createTableEventBridge<TData extends RowData>(
  table: Table<TData>,
  eventBus: EventBus
): TableEventBridge<TData> {
  const tableId = table.id;

  // 1. Wire up table state changes to events
  const unsubscribeState = table.subscribe((state) => {
    emitStateEvents(state, table, eventBus);
  });

  // 2. Create bridge instance
  const bridge: TableEventBridge<TData> = {
    // Event emission methods
    emitEvent: <T extends EventType>(event: T, payload: EventPayload<T>) => {
      eventBus.emit(event, {
        ...payload,
        tableId,
        timestamp: Date.now(),
        source: 'table',
      });
    },

    emitStateUpdate: (previousState, newState, changedKeys) => {
      eventBus.emit('state:update', {
        tableId,
        previousState,
        newState,
        changedKeys,
        timestamp: Date.now(),
      });
    },

    emitDataChange: (changeType, rowIds, data, previousData) => {
      eventBus.emit('data:change', {
        tableId,
        changeType,
        rowIds,
        data,
        previousData,
        timestamp: Date.now(),
        source: 'table',
      });
    },

    // Event subscription methods
    on: <T extends EventType>(
      event: T,
      handler: EventHandler<EventPayload<T>>,
      options?: EventHandlerOptions
    ) => eventBus.on(event, handler, options),

    once: <T extends EventType>(
      event: T,
      handler: EventHandler<EventPayload<T>>
    ) => eventBus.once(event, handler),

    off: <T extends EventType>(
      event: T,
      handler: EventHandler<EventPayload<T>>
    ) => eventBus.off(event, handler),

    // Lifecycle
    destroy: () => {
      unsubscribeState();
      eventBus.clear();
    },

    // Metadata
    eventBus,
    tableId,
  };

  // 3. Emit initialization events
  eventBus.emit('table:init', {
    tableId,
    timestamp: Date.now(),
    columnCount: table.getAllColumns().length,
    rowCount: table.getRowModel().rows.length,
  });

  return bridge;
}
```

### **2. State Event Emitter**

```typescript
// packages/core/src/events/emitters/state-emitters.ts
export function emitStateEvents<TData>(
  state: TableState<TData>,
  table: Table<TData>,
  eventBus: EventBus
): void {
  // Track previous state for diffs
  let previousState: TableState<TData> | undefined;

  // Emit specific events based on state changes
  const changedKeys = detectChangedKeys(previousState, state);

  if (changedKeys.length > 0) {
    // Emit general state update
    eventBus.emit('state:update', {
      tableId: table.id,
      previousState,
      newState: state,
      changedKeys,
      timestamp: Date.now(),
    });

    // Emit specific events
    if (changedKeys.includes('columnVisibility')) {
      emitColumnVisibilityEvents(previousState!, state, table, eventBus);
    }

    if (changedKeys.includes('rowSelection')) {
      emitRowSelectionEvents(previousState!, state, table, eventBus);
    }

    if (changedKeys.includes('sorting')) {
      emitSortingEvents(previousState!, state, table, eventBus);
    }

    if (changedKeys.includes('filtering')) {
      emitFilteringEvents(previousState!, state, table, eventBus);
    }

    if (changedKeys.includes('expanded')) {
      emitExpansionEvents(previousState!, state, table, eventBus);
    }
  }

  previousState = state;
}

function detectChangedKeys<TData>(
  previous: TableState<TData> | undefined,
  current: TableState<TData>
): Array<keyof TableState<TData>> {
  if (!previous) return Object.keys(current) as Array<keyof TableState<TData>>;
  
  const changed: Array<keyof TableState<TData>> = [];
  
  for (const key in current) {
    if (!shallowEqual(previous[key], current[key])) {
      changed.push(key as keyof TableState<TData>);
    }
  }
  
  return changed;
}
```

### **3. Eventful Table Wrapper**

```typescript
// packages/core/src/events/types/eventful-table.ts
export interface EventfulTable<TData extends RowData> extends Table<TData> {
  readonly events: TableEventBridge<TData>;

  // Event shortcuts
  on<T extends EventType>(
    event: T,
    handler: EventHandler<EventPayload<T>>,
    options?: EventHandlerOptions
  ): () => void;

  emit<T extends EventType>(event: T, payload: EventPayload<T>): void;
}

export function createEventfulTable<TData extends RowData>(
  options: TableOptions<TData>
): EventfulTable<TData> {
  const table = createTable(options);
  const eventBus = createEventBus({ devMode: options.debug });
  const eventBridge = createTableEventBridge(table, eventBus);

  const eventfulTable: EventfulTable<TData> = {
    ...table,
    events: eventBridge,

    on: (event, handler, options) => eventBridge.on(event, handler, options),

    emit: (event, payload) => eventBridge.emitEvent(event, payload),

    // Override destroy to cleanup events
    destroy: () => {
      eventBridge.destroy();
      table.destroy();
    },
  };

  return eventfulTable;
}
```

### **4. Bridge Types**

```typescript
// packages/core/src/events/types/event-bridge.ts
export interface TableEventBridge<TData extends RowData> {
  // Event emission
  emitEvent<T extends EventType>(event: T, payload: EventPayload<T>): void;
  emitStateUpdate(
    previousState: TableState<TData>,
    newState: TableState<TData>,
    changedKeys: Array<keyof TableState<TData>>
  ): void;
  emitDataChange(
    changeType: DataChangeType,
    rowIds: RowId[],
    data?: TData[],
    previousData?: TData[]
  ): void;

  // Event subscription
  on<T extends EventType>(
    event: T,
    handler: EventHandler<EventPayload<T>>,
    options?: EventHandlerOptions
  ): () => void;

  once<T extends EventType>(
    event: T,
    handler: EventHandler<EventPayload<T>>
  ): () => void;

  off<T extends EventType>(
    event: T,
    handler: EventHandler<EventPayload<T>>
  ): void;

  // Lifecycle
  destroy(): void;

  // Metadata
  readonly eventBus: EventBus;
  readonly tableId: GridId;
}

export type DataChangeType = 'add' | 'update' | 'delete' | 'replace' | 'bulk';
```

## ðŸš« **DO NOT IMPLEMENT**

- âŒ No column/row event handlers (CORE-014-2)
- âŒ No specific event emitters (CORE-014-3)
- âŒ No UI event handling
- âŒ No framework-specific adapters
- âŒ No event persistence

## ðŸ“ **File Structure**

```
packages/core/src/events/integration/
â”œâ”€â”€ table-event-bridge.ts    # Main bridge implementation
â””â”€â”€ index.ts

packages/core/src/events/emitters/
â”œâ”€â”€ state-emitters.ts        # State change events
â””â”€â”€ index.ts

packages/core/src/events/types/
â”œâ”€â”€ event-bridge.ts          # Bridge types
â”œâ”€â”€ eventful-table.ts        # Event-aware table types
â””â”€â”€ index.ts
```

## ðŸ§ª **Test Requirements**

```typescript
describe('Table Event Bridge', () => {
  test('creates event bridge for table', () => {
    const table = createTable({ columns: [], data: [] });
    const eventBus = createEventBus();
    const bridge = createTableEventBridge(table, eventBus);

    expect(bridge.tableId).toBe(table.id);
    expect(bridge.eventBus).toBe(eventBus);
  });

  test('emits state change events', async () => {
    const table = createTable({ columns: [], data: [] });
    const eventBus = createEventBus();
    createTableEventBridge(table, eventBus);

    const events: any[] = [];
    eventBus.on('state:update', (event) => events.push(event));

    // Change table state
    table.setState({ data: [{ id: 1 }] });

    // Should emit state update event
    await waitFor(() => {
      expect(events).toHaveLength(1);
      expect(events[0].payload.tableId).toBe(table.id);
    });
  });

  test('provides eventful table wrapper', () => {
    const table = createEventfulTable({
      columns: [{ accessorKey: 'id' }],
      data: [{ id: 1 }],
    });

    // Should have event methods
    expect(table.on).toBeDefined();
    expect(table.emit).toBeDefined();
    expect(table.events).toBeDefined();

    // Event subscription should work
    const handler = jest.fn();
    const unsubscribe = table.on('state:update', handler);

    table.setState({ data: [] });
    expect(handler).toHaveBeenCalled();

    unsubscribe();
  });

  test('cleans up events on destroy', () => {
    const table = createEventfulTable({
      columns: [{ accessorKey: 'id' }],
      data: [{ id: 1 }],
    });

    const handler = jest.fn();
    table.on('state:update', handler);

    table.destroy();

    // Should not emit events after destroy
    expect(() => table.destroy()).not.toThrow();
  });

  test('emits initialization event', async () => {
    const table = createTable({
      columns: [{ accessorKey: 'id' }],
      data: [{ id: 1 }, { id: 2 }],
    });
    const eventBus = createEventBus();

    const initEvents: any[] = [];
    eventBus.on('table:init', (event) => initEvents.push(event));

    createTableEventBridge(table, eventBus);

    await waitFor(() => {
      expect(initEvents).toHaveLength(1);
      expect(initEvents[0].payload.tableId).toBe(table.id);
      expect(initEvents[0].payload.columnCount).toBe(1);
      expect(initEvents[0].payload.rowCount).toBe(2);
    });
  });
});
```

## ðŸ“Š **Success Metrics**

- âœ… State change to event emission < 0.5ms
- âœ… Event subscription/unsubscription works correctly
- âœ… Memory usage stable with event listeners
- âœ… Zero event emissions after destroy
- âœ… Event types maintain full type safety

## ðŸŽ¯ **AI Implementation Strategy**

1. **Start with event-bridge.ts** - define types
2. **Implement table-event-bridge.ts** - main bridge
3. **Add state-emitters.ts** - state change events
4. **Create eventful-table.ts** - convenience wrapper
5. **Test event flow integrity** - ensure proper emission

**Critical:** The bridge must not create circular dependencies or infinite loops.

---

**Status:** Ready for implementation. Focus on preventing event loops and ensuring efficient event propagation.
