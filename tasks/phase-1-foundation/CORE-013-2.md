"# CORE-013-2: Row Methods & Cell System

## Task Card

```
task_id: CORE-013-2
priority: P0
complexity: Medium
estimated_tokens: ~4,000
ai_ready: yes
dependencies: [CORE-013-1]
requires_validation: true (state management)
```

## ðŸŽ¯ **Objective**

Implement row selection/expansion methods, complete cell system with caching, and state management integration for row operations.

## ðŸ“‹ **Implementation Scope**

### **1. Selection Methods Implementation**

```typescript
// packages/core/src/row/methods/selection-methods.ts
export function buildSelectionMethods<TData>(
  options: BuildSelectionMethodsOptions<TData>
): SelectionMethods<TData> {
  const { id, table } = options;

  return {
    getIsSelected: () => {
      const state = table.getState();
      return !!state.rowSelection?.[id];
    },

    toggleSelected: (selected?: boolean, selectionOptions?: SelectionOptions) => {
      const state = table.getState();
      const current = !!state.rowSelection?.[id];
      const next = selected ?? !current;

      table.setState((prev) => {
        const nextSelection = { ...prev.rowSelection };

        if (next) {
          nextSelection[id] = true;
        } else {
          delete nextSelection[id];
        }

        // Apply selection options
        if (selectionOptions?.clearOthers && next) {
          // Clear all other selections
          Object.keys(nextSelection).forEach((key) => {
            if (key !== id) delete nextSelection[key];
          });
        }

        // Apply multi-select mode
        if (selectionOptions?.mode === 'multi' && selectionOptions?.range) {
          // Handle range selection
          this.handleRangeSelection(id, nextSelection, table);
        }

        return { ...prev, rowSelection: nextSelection };
      });
    },

    // Bulk selection helper
    selectAll: (selected = true) => {
      table.setState((prev) => {
        const rowModel = table.getRowModel();
        const nextSelection: Record<RowId, boolean> = {};

        if (selected) {
          rowModel.flatRows.forEach((row) => {
            nextSelection[row.id] = true;
          });
        }

        return { ...prev, rowSelection: nextSelection };
      });
    },
  };
}

// Helper for range selection
function handleRangeSelection<TData>(
  targetRowId: RowId,
  selection: Record<RowId, boolean>,
  table: Table<TData>
): void {
  const state = table.getState();
  const rowModel = table.getRowModel();
  
  // Find last selected row
  const selectedRows = Object.keys(state.rowSelection || {});
  const lastSelected = selectedRows[selectedRows.length - 1];
  
  if (lastSelected) {
    const rows = rowModel.flatRows;
    const startIndex = rows.findIndex((r) => r.id === lastSelected);
    const endIndex = rows.findIndex((r) => r.id === targetRowId);
    
    if (startIndex !== -1 && endIndex !== -1) {
      const [min, max] = [startIndex, endIndex].sort((a, b) => a - b);
      
      // Select all rows in range
      for (let i = min; i <= max; i++) {
        selection[rows[i].id] = true;
      }
    }
  }
}
```

### **2. Expansion Methods (Basic)**

```typescript
// packages/core/src/row/methods/expansion-methods.ts
export function buildExpansionMethods<TData>(
  options: BuildExpansionMethodsOptions<TData>
): ExpansionMethods<TData> {
  const { id, table, hasChildren } = options;

  return {
    getIsExpanded: () => {
      if (!hasChildren) return false;
      const state = table.getState();
      return !!state.expanded?.[id];
    },

    toggleExpanded: (expanded?: boolean) => {
      if (!hasChildren) return;

      const state = table.getState();
      const current = !!state.expanded?.[id];
      const next = expanded ?? !current;

      table.setState((prev) => ({
        ...prev,
        expanded: {
          ...prev.expanded,
          [id]: next,
        },
      }));
    },

    expandAll: () => {
      table.setState((prev) => {
        const rowModel = table.getRowModel();
        const expanded: Record<RowId, boolean> = { ...prev.expanded };
        
        rowModel.flatRows.forEach((row) => {
          if (row.hasChildren) {
            expanded[row.id] = true;
          }
        });

        return { ...prev, expanded };
      });
    },

    collapseAll: () => {
      table.setState((prev) => ({
        ...prev,
        expanded: {},
      }));
    },
  };
}
```

### **3. Complete Cell Factory**

```typescript
// packages/core/src/row/cell/create-cell.ts
export function createCell<TData, TValue>(
  row: Row<TData>,
  column: Column<TData, TValue>
): Cell<TData, TValue> {
  const cellId = createCellId(row.id, column.id);

  const cell: Cell<TData, TValue> = {
    id: cellId,
    row,
    column,

    getValue: () => {
      const accessor = (column as any)._internal?.accessor;
      if (!accessor) {
        throw new GridError(
          'NO_ACCESSOR',
          `No accessor for column ${column.id}`
        );
      }

      return accessor.getValue(row.original, row.originalIndex);
    },

    renderValue: () => {
      const value = cell.getValue();
      const cellRenderer = column.columnDef.cell;

      if (cellRenderer) {
        const context: CellContext<TData, TValue> = {
          getValue: () => value,
          getRow: () => row,
          column,
          table: row.table,
          rowIndex: row.index,
          cellIndex: column.getIndex(),
          getIsSelected: () => row.getIsSelected(),
          renderValue: () => value,
          meta: column.columnDef.meta?.cell || {},
        };

        return cellRenderer(context);
      }

      return value;
    },

    getIsFocused: () => {
      const state = row.table.getState();
      return (
        state.focusedCell?.rowId === row.id &&
        state.focusedCell?.columnId === column.id
      );
    },

    getIsSelected: () => {
      return row.getIsSelected();
    },

    getIsEditable: () => {
      const meta = column.columnDef.meta?.cell;
      return meta?.editable === true;
    },

    meta: column.columnDef.meta?.cell || {},
    index: column.getIndex(),

    // Position (for virtualization)
    get position(): CellPosition | undefined {
      // Will be set by virtualization system
      return undefined;
    },
  };

  return cell;
}

// Cell ID generator
function createCellId(rowId: RowId, columnId: ColumnId): string {
  return `${rowId}:${columnId}`;
}
```

### **4. Advanced Cell Caching**

```typescript
// packages/core/src/row/cell/cell-cache.ts
export class CellCache<TData> {
  private cache = new Map<string, Cell<TData>>();
  private pending = new Set<string>();
  private maxSize = 10000;

  getCell(row: Row<TData>, column: Column<TData>): Cell<TData> {
    const cacheKey = this.getCacheKey(row.id, column.id);
    const cached = this.cache.get(cacheKey);

    if (cached) {
      return cached;
    }

    // Lazy creation for performance
    if (!this.pending.has(cacheKey)) {
      this.pending.add(cacheKey);
      
      // Schedule creation in microtask
      queueMicrotask(() => {
        const cell = createCell(row, column);
        this.cache.set(cacheKey, cell);
        this.pending.delete(cacheKey);
        
        // Cleanup if cache too large
        this.cleanupIfNeeded();
      });
    }

    // Return placeholder
    return this.createPlaceholderCell(row, column);
  }

  private getCacheKey(rowId: RowId, columnId: ColumnId): string {
    return `${rowId}:${columnId}`;
  }

  private createPlaceholderCell(row: Row<TData>, column: Column<TData>): Cell<TData> {
    return {
      id: this.getCacheKey(row.id, column.id),
      row,
      column,
      getValue: () => {
        // Will be replaced when real cell is created
        const realCell = this.cache.get(this.getCacheKey(row.id, column.id));
        if (realCell) return realCell.getValue();
        
        // Fallback to direct access
        const accessor = (column as any)._internal?.accessor;
        return accessor?.getValue(row.original, row.originalIndex);
      },
      renderValue: () => undefined,
      getIsFocused: () => false,
      getIsSelected: () => false,
      getIsEditable: () => false,
      meta: {},
      index: column.getIndex(),
    };
  }

  private cleanupIfNeeded(): void {
    if (this.cache.size > this.maxSize) {
      // Remove oldest entries (simple LRU)
      const keys = Array.from(this.cache.keys());
      const toRemove = keys.slice(0, Math.floor(this.maxSize * 0.1)); // Remove 10%
      toRemove.forEach(key => this.cache.delete(key));
    }
  }

  clear(): void {
    this.cache.clear();
    this.pending.clear();
  }

  size(): number {
    return this.cache.size;
  }
}
```

## ðŸš« **DO NOT IMPLEMENT**

- âŒ No hierarchical data support (CORE-013-3)
- âŒ No tree operations
- âŒ No DOM rendering
- âŒ No complex data transformations
- âŒ No virtualization position calculations

## ðŸ“ **File Structure**

```
packages/core/src/row/methods/
â”œâ”€â”€ selection-methods.ts    # Row selection logic
â”œâ”€â”€ expansion-methods.ts    # Row expansion logic
â””â”€â”€ index.ts

packages/core/src/row/cell/
â”œâ”€â”€ create-cell.ts          # Complete cell factory
â”œâ”€â”€ cell-cache.ts           # Advanced caching
â””â”€â”€ index.ts
```

## ðŸ§ª **Test Requirements**

```typescript
describe('Row Methods & Cell System', () => {
  test('manages row selection state', () => {
    const table = mockTable();
    const row = createRowInstance({
      originalData: { id: 1, name: 'Alice' },
      originalIndex: 0,
      columns: [mockColumn('name')],
      getRowId: (row) => row.id.toString(),
      table,
    });

    // Inject selection methods
    const selectionMethods = buildSelectionMethods({ id: row.id, table });
    (row as any).getIsSelected = selectionMethods.getIsSelected;
    (row as any).toggleSelected = selectionMethods.toggleSelected;

    expect(row.getIsSelected()).toBe(false);

    row.toggleSelected(true);
    expect(row.getIsSelected()).toBe(true);

    row.toggleSelected(); // Toggle
    expect(row.getIsSelected()).toBe(false);
  });

  test('handles range selection', () => {
    const table = mockTableWithRows(5);
    const rows = table.getRowModel().rows;

    // Select first row
    rows[0].toggleSelected(true);
    
    // Select third row with range
    rows[2].toggleSelected(true, { mode: 'multi', range: true });

    const state = table.getState();
    expect(state.rowSelection?.[rows[0].id]).toBe(true);
    expect(state.rowSelection?.[rows[1].id]).toBe(true); // Should be selected via range
    expect(state.rowSelection?.[rows[2].id]).toBe(true);
  });

  test('creates complete cell instances', () => {
    const row = createRowInstance({
      originalData: { id: 1, name: 'Alice' },
      originalIndex: 0,
      columns: [mockColumn('name')],
      getRowId: (row) => row.id.toString(),
      table: mockTable(),
    });

    const column = mockColumn('name');
    const cell = createCell(row, column);

    expect(cell.id).toBe('1:name');
    expect(cell.row).toBe(row);
    expect(cell.column).toBe(column);
    expect(cell.getValue()).toBe('Alice');
  });

  test('cell cache provides lazy creation', () => {
    const cache = new CellCache();
    const row = createRowInstance({
      originalData: { id: 1, name: 'Alice' },
      originalIndex: 0,
      columns: [mockColumn('name')],
      getRowId: (row) => row.id.toString(),
      table: mockTable(),
    });

    const column = mockColumn('name');
    
    // First call creates placeholder
    const cell1 = cache.getCell(row, column);
    expect(cell1.getValue()).toBe('Alice'); // Should work even with placeholder
    
    // Wait for microtask
    await new Promise(resolve => queueMicrotask(resolve));
    
    // Second call should get cached cell
    const cell2 = cache.getCell(row, column);
    expect(cell1).not.toBe(cell2); // Different references (placeholder vs real)
  });

  test('expansion methods work with child rows', () => {
    const table = mockTable();
    const row = createRowInstance({
      originalData: { id: 1, name: 'Parent', children: [] },
      originalIndex: 0,
      columns: [mockColumn('name')],
      getRowId: (row) => row.id.toString(),
      table,
      hasChildren: true,
    });

    const expansionMethods = buildExpansionMethods({ 
      id: row.id, 
      table, 
      hasChildren: true 
    });
    (row as any).getIsExpanded = expansionMethods.getIsExpanded;
    (row as any).toggleExpanded = expansionMethods.toggleExpanded;

    expect(row.getIsExpanded()).toBe(false);
    
    row.toggleExpanded(true);
    expect(row.getIsExpanded()).toBe(true);
  });
});
```

## ðŸ“Š **Success Metrics**

- âœ… Selection operations < 1ms
- âœ… Cell creation/caching < 0.5ms
- âœ… Range selection works correctly
- âœ… Memory efficient cell caching
- âœ… No state update loops

## ðŸŽ¯ **AI Implementation Strategy**

1. **Start with selection-methods.ts** - basic selection
2. **Implement expansion-methods.ts** - row expansion
3. **Complete create-cell.ts** - full cell factory
4. **Add cell-cache.ts** - advanced caching
5. **Test state integration** - ensure proper updates

**Critical:** The cell caching must handle large datasets without memory issues.

---

**Status:** Ready for implementation. Focus on state management and performance."