"# CORE-013-1: Row Factory & Basic Model

## Task Card

```
task_id: CORE-013-1
priority: P0
complexity: Medium
estimated_tokens: ~4,000
ai_ready: yes
dependencies: [CORE-001, CORE-002, CORE-003, CORE-004, CORE-012]
requires_validation: true (data structures)
```

## ðŸŽ¯ **Objective**

Implement row factory system that creates row instances from data, manages basic row model with indexing, and provides efficient data access patterns for flat data structures.

## ðŸ“‹ **Implementation Scope**

### **1. Row Model Builder**

```typescript
// packages/core/src/row/factory/build-row-model.ts
export function buildRowModel<TData extends RowData>(
  options: BuildRowModelOptions<TData>
): RowModel<TData> {
  const {
    data,
    columns,
    getRowId,
    table,
    parentRow,
    depth = 0,
    path = [],
  } = options;

  // 1. Create row instances
  const rows: Row<TData>[] = [];
  const flatRows: Row<TData>[] = [];
  const rowsById = new Map<RowId, Row<TData>>();
  const rowsByOriginalIndex = new Map<number, Row<TData>>();

  // 2. Process each data item
  data.forEach((originalData, originalIndex) => {
    const row = createRowInstance({
      originalData,
      originalIndex,
      columns,
      getRowId,
      table,
      parentRow,
      depth,
      path,
    });

    rows.push(row);
    flatRows.push(row);
    rowsById.set(row.id, row);
    rowsByOriginalIndex.set(originalIndex, row);
  });

  // 3. Create model instance
  const model: RowModel<TData> = {
    rows,
    flatRows,
    rowsById,
    rowsByOriginalIndex,

    // Computed properties
    totalRowCount: rows.length,
    totalFlatRowCount: flatRows.length,

    // Methods
    getRow: (id) => rowsById.get(id),
    getRowByOriginalIndex: (index) => rowsByOriginalIndex.get(index),

    getSelectedRows: () => {
      const state = table.getState();
      return flatRows.filter((row) => state.rowSelection?.[row.id]);
    },

    getExpandedRows: () => {
      const state = table.getState();
      return flatRows.filter((row) => state.expanded?.[row.id]);
    },

    filterRows: (predicate) => {
      return flatRows.filter((row, index, array) =>
        predicate(row, index, array)
      );
    },

    findRow: (predicate) => {
      return flatRows.find((row, index, array) => predicate(row, index, array));
    },

    // Metadata
    meta: {
      depth,
      path,
      processingTime: 0,
      hasHierarchicalData: false, // Flat data only in this task
    },
  };

  return model;
}

// Types
type BuildRowModelOptions<TData> = {
  data: TData[];
  columns: Column<TData>[];
  getRowId: (row: TData, index: number) => RowId;
  table: Table<TData>;
  parentRow?: Row<TData>;
  depth?: number;
  path?: RowId[];
};
```

### **2. Row Instance Creation**

```typescript
// packages/core/src/row/factory/create-row.ts
export function createRowInstance<TData extends RowData>(
  options: CreateRowOptions<TData>
): Row<TData> {
  const {
    originalData,
    originalIndex,
    columns,
    getRowId,
    table,
    parentRow,
    depth,
    path,
  } = options;

  // Generate row ID
  const id = getRowId(originalData, originalIndex);

  // Create cell cache for performance
  const cellCache = new Map<ColumnId, Cell<TData>>();

  // Build basic row methods (cell access only)
  const methods = buildBasicRowMethods({
    id,
    originalData,
    table,
    columns,
    cellCache,
  });

  // Create row instance
  const row: Row<TData> = {
    // Core properties
    id,
    table,
    original: Object.freeze(originalData),
    originalIndex,
    index: originalIndex, // Will be updated by row model

    // Hierarchical properties (basic)
    depth,
    parentRow,
    subRows: [],
    hasChildren: false,

    // Basic methods (selection/expansion in next task)
    getAllCells: methods.getAllCells,
    getVisibleCells: methods.getVisibleCells,
    getCell: methods.getCell,
    getValue: methods.getValue,
    getOriginalValue: methods.getOriginalValue,

    // Placeholders for methods in next tasks
    getIsSelected: () => false,
    toggleSelected: () => {},
    getIsExpanded: () => false,
    toggleExpanded: () => {},
    getParentRows: () => [],
    getLeafRows: () => [],
    getPath: () => [...path, id],
    isAncestorOf: () => false,
    isDescendantOf: () => false,

    // Metadata
    meta: {},
    isVisible: true,
  };

  // Initialize cell cache
  initializeCellCache(row, columns, cellCache);

  return row;
}

// Types
type CreateRowOptions<TData> = {
  originalData: TData;
  originalIndex: number;
  columns: Column<TData>[];
  getRowId: (row: TData, index: number) => RowId;
  table: Table<TData>;
  parentRow?: Row<TData>;
  depth?: number;
  path?: RowId[];
};
```

### **3. Basic Row Methods**

```typescript
// packages/core/src/row/methods/basic-methods.ts
export function buildBasicRowMethods<TData>(
  options: BuildBasicRowMethodsOptions<TData>
): BasicRowMethods<TData> {
  const { id, table, columns, cellCache } = options;

  return {
    // Cell access methods
    getAllCells: () => {
      const cells: Cell<TData>[] = [];
      columns.forEach((column) => {
        const cell = cellCache.get(column.id);
        if (cell) cells.push(cell);
      });
      return cells;
    },

    getVisibleCells: () => {
      const state = table.getState();
      const cells: Cell<TData>[] = [];

      columns.forEach((column) => {
        if (state.columnVisibility?.[column.id] !== false) {
          const cell = cellCache.get(column.id);
          if (cell) cells.push(cell);
        }
      });

      return cells;
    },

    getCell: (columnId) => {
      return cellCache.get(columnId);
    },

    getValue: <TValue = unknown>(columnId: ColumnId): TValue => {
      const cell = cellCache.get(columnId);
      if (!cell) {
        throw new GridError('CELL_NOT_FOUND', `Cell not found: ${columnId}`, {
          rowId: id,
          columnId,
        });
      }
      return cell.getValue() as TValue;
    },

    getOriginalValue: (columnId) => {
      // Direct access without column accessor
      const path = columnId.split('.');
      let value: any = options.originalData;

      for (const key of path) {
        if (value == null) return undefined;
        value = value[key];
      }

      return value;
    },
  };
}
```

### **4. Row Registry for Indexing**

```typescript
// packages/core/src/row/factory/row-registry.ts
export class RowRegistry<TData> {
  private byId = new Map<RowId, Row<TData>>();
  private byOriginalIndex = new Map<number, Row<TData>>();
  private byParent = new Map<RowId, Row<TData>[]>();

  add(row: Row<TData>): void {
    this.byId.set(row.id, row);
    this.byOriginalIndex.set(row.originalIndex, row);

    if (row.parentRow) {
      const siblings = this.byParent.get(row.parentRow.id) || [];
      siblings.push(row);
      this.byParent.set(row.parentRow.id, siblings);
    }
  }

  remove(rowId: RowId): boolean {
    const row = this.byId.get(rowId);
    if (!row) return false;

    this.byId.delete(rowId);
    this.byOriginalIndex.delete(row.originalIndex);

    if (row.parentRow) {
      const siblings = this.byParent.get(row.parentRow.id);
      if (siblings) {
        const index = siblings.findIndex((r) => r.id === rowId);
        if (index !== -1) {
          siblings.splice(index, 1);
        }
      }
    }

    return true;
  }

  getById(rowId: RowId): Row<TData> | undefined {
    return this.byId.get(rowId);
  }

  getByOriginalIndex(index: number): Row<TData> | undefined {
    return this.byOriginalIndex.get(index);
  }

  getChildren(parentId: RowId): Row<TData>[] {
    return this.byParent.get(parentId) || [];
  }

  clear(): void {
    this.byId.clear();
    this.byOriginalIndex.clear();
    this.byParent.clear();
  }

  size(): number {
    return this.byId.size;
  }
}
```

## ðŸš« **DO NOT IMPLEMENT**

- âŒ No hierarchical data support (CORE-013-3)
- âŒ No selection/expansion methods (CORE-013-2)
- âŒ No tree operations
- âŒ No complex data transformations
- âŒ No DOM rendering

## ðŸ“ **File Structure**

```
packages/core/src/row/factory/
â”œâ”€â”€ build-row-model.ts      # Main model builder
â”œâ”€â”€ create-row.ts           # Single row creation
â”œâ”€â”€ row-registry.ts         # Row indexing
â””â”€â”€ index.ts

packages/core/src/row/methods/
â”œâ”€â”€ basic-methods.ts        # Basic cell access methods
â””â”€â”€ index.ts

packages/core/src/row/cell/
â”œâ”€â”€ create-cell.ts          # Cell factory (basic)
â””â”€â”€ cell-cache.ts           # Cell caching system
```

## ðŸ§ª **Test Requirements**

```typescript
describe('Row Factory & Basic Model', () => {
  test('creates row model from flat data', () => {
    const data = [
      { id: 1, name: 'Alice' },
      { id: 2, name: 'Bob' },
    ];
    const model = buildRowModel({
      data,
      columns: [mockColumn('name')],
      getRowId: (row) => row.id.toString(),
      table: mockTable(),
    });

    expect(model.rows).toHaveLength(2);
    expect(model.flatRows).toHaveLength(2);
    expect(model.rowsById.size).toBe(2);
  });

  test('creates row instances with cell cache', () => {
    const row = createRowInstance({
      originalData: { id: 1, name: 'Alice' },
      originalIndex: 0,
      columns: [mockColumn('name')],
      getRowId: (row) => row.id.toString(),
      table: mockTable(),
    });

    expect(row.id).toBe('1');
    expect(row.originalIndex).toBe(0);
    expect(row.getAllCells()).toHaveLength(1);
  });

  test('provides efficient cell access', () => {
    const row = createRowInstance({
      originalData: { id: 1, name: 'Alice', age: 30 },
      originalIndex: 0,
      columns: [mockColumn('name'), mockColumn('age')],
      getRowId: (row) => row.id.toString(),
      table: mockTable(),
    });

    // Should cache cells for performance
    const cell1 = row.getCell('name');
    const cell2 = row.getCell('name');
    expect(cell1).toBe(cell2); // Same reference

    // Should get typed value
    const value = row.getValue<string>('name');
    expect(value).toBe('Alice');
  });

  test('row registry provides O(1) lookups', () => {
    const registry = new RowRegistry();
    const row = createRowInstance({
      originalData: { id: 1, name: 'Alice' },
      originalIndex: 0,
      columns: [mockColumn('name')],
      getRowId: (row) => row.id.toString(),
      table: mockTable(),
    });

    registry.add(row);

    expect(registry.getById('1')).toBe(row);
    expect(registry.getByOriginalIndex(0)).toBe(row);
    expect(registry.size()).toBe(1);
  });

  test('handles large datasets efficiently', () => {
    const data = Array.from({ length: 1000 }, (_, i) => ({
      id: i,
      name: `User ${i}`,
    }));

    const start = performance.now();
    const model = buildRowModel({
      data,
      columns: [mockColumn('name')],
      getRowId: (row) => row.id.toString(),
      table: mockTable(),
    });
    const end = performance.now();

    expect(model.rows).toHaveLength(1000);
    expect(end - start).toBeLessThan(100); // < 100ms for 1000 rows
  });
});
```

## ðŸ“Š **Success Metrics**

- âœ… Build model with 10,000 rows < 100ms
- âœ… Get cell value < 0.1ms (cached)
- âœ… Memory usage scales O(n) with data size
- âœ… Row registry provides O(1) lookups
- âœ… No memory leaks in row/cell caching

## ðŸŽ¯ **AI Implementation Strategy**

1. **Start with create-row.ts** - basic row instance
2. **Implement build-row-model.ts** - model builder
3. **Add row-registry.ts** - indexing system
4. **Create basic-methods.ts** - cell access methods
5. **Test performance** - large datasets and caching

**Critical:** The cell caching must be memory-efficient and prevent leaks.

---

**Status:** Ready for implementation. Focus on performance and memory efficiency for flat data."